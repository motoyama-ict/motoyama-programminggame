<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ëø∑Ë∑Ø„Ç≤„Éº„É†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=M+PLUS+Rounded+1c:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'M PLUS Rounded 1c', sans-serif;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            aspect-ratio: 1 / 1;
            border: 2px solid #334155;
            background-color: #f1f5f9;
        }
        .tile {
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 0 1px #e2e8f0; /* „Ç∞„É™„ÉÉ„ÉâÁ∑ö„ÇíËøΩÂä† */
        }
        .wall {
            background-color: #475569;
        }
        .goal {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ef4444' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z'/%3E%3Cline x1='4' y1='22' x2='4' y2='15'/%3E%3C/svg%3E");
            background-size: 80%;
            background-repeat: no-repeat;
            background-position: center;
        }
        #player {
            position: absolute;
            width: calc(100% / 10);
            height: calc(100% / 10);
            transition: all 0.3s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* ÁµµÊñáÂ≠ó„ÅÆ„Çµ„Ç§„Ç∫Ë™øÊï¥ */
        }
        .command-block {
            cursor: pointer;
            transition: transform 0.1s;
        }
        .command-block:hover {
            transform: scale(1.05);
        }
        .command-block:active {
            transform: scale(0.98);
        }
        #workspace .command-block {
             cursor: grab;
        }
        .executing {
            outline: 3px solid #facc15; /* yellow-400 */
            outline-offset: 2px;
            border-radius: 6px; /* Match the block's rounding */
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4 md:p-8">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-700">„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ëø∑Ë∑Ø„Ç≤„Éº„É†</h1>
            <div class="flex justify-center items-center gap-4 mt-2">
                <p id="level-title" class="text-lg text-slate-500"></p>
                <select id="stage-select" class="bg-white border border-slate-300 rounded-md py-1 px-2 text-slate-700 shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500"></select>
            </div>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- „Ç≤„Éº„É†ÁîªÈù¢ -->
            <div class="bg-white p-4 rounded-xl shadow-lg">
                <div id="game-container" class="relative">
                    <div id="game-board" class="game-board rounded-lg overflow-hidden"></div>
                    <div id="player">ü§ñ</div>
                </div>
            </div>

            <!-- Êìç‰Ωú„Éë„Éç„É´ -->
            <div class="flex flex-col gap-4">
                <div class="bg-white p-4 rounded-xl shadow-lg">
                    <h2 class="text-xl font-semibold mb-3 border-b pb-2">„Ç≥„Éû„É≥„Éâ„ÇíÈÅ∏„Åº„ÅÜ</h2>
                    <div id="block-palette" class="flex flex-wrap gap-3">
                        <div class="command-block bg-blue-500 text-white p-3 rounded-lg text-center font-semibold shadow" data-command="forward">„Åæ„Åà„Å´ „Åô„Åô„ÇÄ</div>
                        <div class="command-block bg-green-500 text-white p-3 rounded-lg text-center font-semibold shadow" data-command="turnRight">„Åø„Åé„Çí „ÇÄ„Åè</div>
                        <div class="command-block bg-orange-500 text-white p-3 rounded-lg text-center font-semibold shadow" data-command="turnLeft">„Å≤„Å†„Çä„Çí „ÇÄ„Åè</div>
                        <div class="command-block bg-purple-500 text-white p-2 rounded-lg text-center font-semibold shadow flex items-center gap-2" data-command="loopStart">
                            <input type="number" min="1" max="10" value="2" class="w-12 text-black text-center rounded" onclick="event.stopPropagation()">
                             „Åã„ÅÑ „Åè„Çä„Åã„Åà„Åô
                        </div>
                        <div class="command-block bg-purple-500 text-white p-3 rounded-lg text-center font-semibold shadow" data-command="loopEnd">„Åì„Åì„Åæ„Åß</div>
                    </div>
                </div>

                <div id="action-buttons" class="grid grid-cols-3 gap-4">
                     <button id="run-button" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                        „Åò„Å£„Åì„ÅÜ
                    </button>
                    <button id="reset-button" class="bg-rose-500 hover:bg-rose-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                        „É™„Çª„ÉÉ„Éà
                    </button>
                    <button id="clear-button" class="bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">
                        „Éó„É≠„Ç∞„É©„É†„Çí„ÇØ„É™„Ç¢
                    </button>
                </div>

                <div class="bg-white p-4 rounded-xl shadow-lg flex-grow min-h-[200px] flex flex-col">
                    <h2 class="text-xl font-semibold mb-3 border-b pb-2">„Éó„É≠„Ç∞„É©„É†„Çí‰Ωú„Çç„ÅÜ</h2>
                    <div id="workspace" class="bg-slate-100 flex-grow rounded-md p-2 space-y-2 overflow-y-auto">
                        <!-- „Åì„Åì„Å´„Ç≥„Éû„É≥„Éâ„Éñ„É≠„ÉÉ„ÇØ„ÅåËøΩÂä†„Åï„Çå„Çã -->
                    </div>
                </div>
                
            </div>
        </div>
    </div>
    
    <!-- „É°„ÉÉ„Çª„Éº„Ç∏„É¢„Éº„ÉÄ„É´ -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div id="modal-content" class="bg-white rounded-2xl shadow-2xl p-8 text-center max-w-sm w-full">
            <h2 id="modal-title" class="text-3xl font-bold mb-4"></h2>
            <p id="modal-message" class="text-slate-600 mb-6"></p>
            <button id="modal-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">
                OK
            </button>
        </div>
    </div>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const levels = [
            {
                title: "„Çπ„ÉÜ„Éº„Ç∏ 1: „Åæ„Åö„ÅØ„Ç¥„Éº„É´üö©„Åæ„ÅßÂãï„Åã„Åó„Å¶„Åø„Çà„ÅÜÔºÅ",
                grid: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 2, 1],
                    [1, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                    [1, 1, 1, 1, 0, 1, 0, 0, 0, 1],
                    [1, 0, 0, 0, 0, 1, 1, 1, 1, 1],
                    [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                ],
                start: { x: 1, y: 1, dir: 'right' }
            },
            {
                title: "„Çπ„ÉÜ„Éº„Ç∏ 2: „Åæ„Åå„ÇäËßí„ÅåÂ§ö„ÅÑ„ÅûÔºÅ",
                grid: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 1, 2, 1, 0, 1],
                    [1, 1, 1, 0, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 1, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 1, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                ],
                start: { x: 1, y: 1, dir: 'down' }
            },
            {
                title: "„Çπ„ÉÜ„Éº„Ç∏ 3: „Åè„Çä„Åã„Åà„Åó„ÅßÈï∑„ÅÑÈÅì„ÇíÈÄ≤„ÇÇ„ÅÜÔºÅ",
                grid: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 2],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                ],
                start: { x: 1, y: 1, dir: 'right' }
            }
        ];

        let currentLevelIndex = 0;
        let player = {};
        let isRunning = false;
        
        const gameBoard = document.getElementById('game-board');
        const playerElement = document.getElementById('player');
        const workspace = document.getElementById('workspace');
        const stageSelect = document.getElementById('stage-select');

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function populateStageSelector() {
            stageSelect.innerHTML = '';
            levels.forEach((level, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `„Çπ„ÉÜ„Éº„Ç∏ ${index + 1}`;
                stageSelect.appendChild(option);
            });
        }

        function loadLevel(levelIndex) {
            currentLevelIndex = levelIndex;
            const level = levels[levelIndex];
            if (!level) return;
            
            document.getElementById('level-title').textContent = level.title;
            stageSelect.value = levelIndex;
            player = { ...level.start };
            
            renderBoard();
            renderPlayer();
            resetWorkspace();
        }

        function renderBoard() {
            gameBoard.innerHTML = '';
            const grid = levels[currentLevelIndex].grid;
            grid.forEach(row => {
                row.forEach(tileType => {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    if (tileType === 1) tile.classList.add('wall');
                    if (tileType === 2) tile.classList.add('goal');
                    gameBoard.appendChild(tile);
                });
            });
        }
        
        function renderPlayer() {
            if (!gameBoard.offsetWidth) return;
            const boardSize = gameBoard.offsetWidth;
            const tileSize = boardSize / 10;
            playerElement.style.left = `${player.x * tileSize}px`;
            playerElement.style.top = `${player.y * tileSize}px`;

            let rotation = 0;
            if (player.dir === 'right') rotation = 90;
            if (player.dir === 'down') rotation = 180;
            if (player.dir === 'left') rotation = 270;
            playerElement.style.transform = `rotate(${rotation}deg)`;
        }

        function addCommandToWorkspace(command, sourceElement) {
            const block = document.createElement('div');
            block.dataset.command = command;

            if (command === 'loopStart') {
                const input = sourceElement.querySelector('input');
                const count = input ? input.value : '2';
                block.dataset.count = count;
                block.textContent = `${count} „Åã„ÅÑ „Åè„Çä„Åã„Åà„Åô`;
            } else {
                block.textContent = getCommandText(command);
            }
            
            block.className = `command-block p-2 rounded-md text-white font-medium text-sm ${getCommandColor(command)}`;
            block.addEventListener('click', () => {
                workspace.removeChild(block);
            });
            workspace.appendChild(block);
        }
        
        function getCommandText(command) {
            switch(command) {
                case 'forward': return '„Åæ„Åà„Å´ „Åô„Åô„ÇÄ';
                case 'turnRight': return '„Åø„Åé„Çí „ÇÄ„Åè';
                case 'turnLeft': return '„Å≤„Å†„Çä„Çí „ÇÄ„Åè';
                case 'loopStart': return '„Åè„Çä„Åã„Åà„Åô';
                case 'loopEnd': return '„Åì„Åì„Åæ„Åß';
                default: return '';
            }
        }

        function getCommandColor(command) {
            switch(command) {
                case 'forward': return 'bg-blue-500';
                case 'turnRight': return 'bg-green-500';
                case 'turnLeft': return 'bg-orange-500';
                case 'loopStart':
                case 'loopEnd': return 'bg-purple-500';
                default: return 'bg-gray-400';
            }
        }

        async function runCommands() {
            if (isRunning) return;
            isRunning = true;
            toggleButtons(false);

            const commandElements = Array.from(workspace.children);

            const findMatchingEnd = (startIndex) => {
                let nestingLevel = 1;
                for (let i = startIndex + 1; i < commandElements.length; i++) {
                    const cmd = commandElements[i].dataset.command;
                    if (cmd === 'loopStart') nestingLevel++;
                    if (cmd === 'loopEnd') nestingLevel--;
                    if (nestingLevel === 0) return i;
                }
                return -1;
            };

            const execute = async (startIndex, endIndex) => {
                for (let i = startIndex; i < endIndex; i++) {
                    if (!isRunning) return false;

                    const element = commandElements[i];
                    const command = element.dataset.command;

                    if (command === 'loopStart') {
                        const loopCount = parseInt(element.dataset.count, 10) || 0;
                        const endLoopIndex = findMatchingEnd(i);
                        
                        if (endLoopIndex !== -1 && endLoopIndex < endIndex) {
                            for (let k = 0; k < loopCount; k++) {
                                if (!isRunning) break;
                                const goalReached = await execute(i + 1, endLoopIndex);
                                if (goalReached) return true;
                            }
                            i = endLoopIndex;
                        } else {
                            console.error("Mismatched loop blocks!");
                            break; 
                        }
                    } else if (command !== 'loopEnd') {
                        element.classList.add('executing');

                        switch(command) {
                            case 'forward': moveForward(); break;
                            case 'turnRight': turnRight(); break;
                            case 'turnLeft': turnLeft(); break;
                        }
                        renderPlayer();

                        const grid = levels[currentLevelIndex].grid;
                        if (grid[player.y][player.x] === 2) {
                            await sleep(300);
                            commandElements.forEach(el => el.classList.remove('executing')); // Clean up highlights
                            showModal('„ÇØ„É™„Ç¢ÔºÅ', '„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅ„Ç¥„Éº„É´„Å´„Åü„Å©„ÇäÁùÄ„ÅÑ„Åü„Å≠„ÄÇ', () => {
                                currentLevelIndex++;
                                if (currentLevelIndex >= levels.length) {
                                    showModal('ÂÖ®„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢ÔºÅ', '„Åô„Åî„ÅÑÔºÅ„Åô„Åπ„Å¶„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Çí„ÇØ„É™„Ç¢„Åó„Åü„Å≠ÔºÅ', () => {
                                        currentLevelIndex = 0;
                                        loadLevel(currentLevelIndex);
                                    });
                                } else {
                                    loadLevel(currentLevelIndex);
                                }
                            });
                            return true;
                        }
                        await sleep(400);
                        element.classList.remove('executing');
                    }
                }
                return false;
            };

            await execute(0, commandElements.length);
            resetRunState();
        }
        
        function moveForward() {
            let newX = player.x;
            let newY = player.y;

            if (player.dir === 'up') newY--;
            if (player.dir === 'right') newX++;
            if (player.dir === 'down') newY++;
            if (player.dir === 'left') newX--;
            
            const grid = levels[currentLevelIndex].grid;
            if (newX >= 0 && newX < 10 && newY >= 0 && newY < 10 && grid[newY][newX] !== 1) {
                player.x = newX;
                player.y = newY;
            } else {
                console.log("Â£Å„Å´„Å∂„Å§„Åã„Å£„ÅüÔºÅ");
            }
        }

        function turnRight() {
            const dirs = ['up', 'right', 'down', 'left'];
            const currentDirIndex = dirs.indexOf(player.dir);
            player.dir = dirs[(currentDirIndex + 1) % 4];
        }

        function turnLeft() {
            const dirs = ['up', 'right', 'down', 'left'];
            const currentDirIndex = dirs.indexOf(player.dir);
            player.dir = dirs[(currentDirIndex - 1 + 4) % 4];
        }
        
        function resetGame() {
            if(isRunning) {
                isRunning = false;
            }
            document.querySelectorAll('#workspace .executing').forEach(el => el.classList.remove('executing'));
            player = { ...levels[currentLevelIndex].start };
            renderPlayer();
            toggleButtons(true);
        }

        function resetWorkspace() {
             workspace.innerHTML = '';
        }

        function resetRunState() {
             isRunning = false;
             document.querySelectorAll('#workspace .executing').forEach(el => el.classList.remove('executing'));
             toggleButtons(true);
        }

        function toggleButtons(enabled) {
            document.getElementById('run-button').disabled = !enabled;
            document.getElementById('reset-button').disabled = !enabled;
            document.getElementById('clear-button').disabled = !enabled;
            document.querySelectorAll('#block-palette .command-block').forEach(b => b.style.pointerEvents = enabled ? 'auto' : 'none');

            const buttons = ['run-button', 'reset-button', 'clear-button'];
            buttons.forEach(id => {
                const button = document.getElementById(id);
                if (enabled) {
                    button.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                }
            });
        }
        
        function showModal(title, message, onConfirm) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            const modal = document.getElementById('modal');
            modal.classList.remove('hidden');

            const confirmButton = document.getElementById('modal-button');
            const newConfirmButton = confirmButton.cloneNode(true);
            confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
            
            newConfirmButton.onclick = () => {
                modal.classList.add('hidden');
                if (onConfirm) onConfirm();
            };
        }

        document.querySelectorAll('#block-palette .command-block').forEach(block => {
            block.addEventListener('click', (e) => {
                if (!isRunning) {
                    addCommandToWorkspace(block.dataset.command, e.currentTarget);
                }
            });
        });
        
        stageSelect.addEventListener('change', (e) => {
            const selectedIndex = parseInt(e.target.value, 10);
            loadLevel(selectedIndex);
        });

        document.getElementById('run-button').addEventListener('click', runCommands);
        document.getElementById('reset-button').addEventListener('click', resetGame);
        document.getElementById('clear-button').addEventListener('click', resetWorkspace);
        
        window.addEventListener('resize', renderPlayer);

        populateStageSelector();
        loadLevel(currentLevelIndex);
        setTimeout(renderPlayer, 100);
    });
</script>

</body>
</html>




